# -*- coding: utf-8 -*-
"""COMPUTATIONAL ASSIGNMENT 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RfjbKSD_ZsLQUA5Lbos7c0g1woxD34QB

# PROBLEM - 1
"""

#Problem 1
import numpy as np
import matplotlib.pyplot as plt


def dydt(y,t):
    return 5*y-5*t**(2)

def f(t):
    return t**(2)+(2/5)*t+(2/25)

n = np.array([25,250,2500])
for i in range(len(n)):
    t = np.linspace(0,2,n[i])
    h = t[1]-t[0]


def euler(y,t):
    y = np.zeros(len(t))
    y[0] = 2/25
    #plt.plot(t,f(t))
    #plt.show()
    for i in range(len(t)-1):
        y[i+1] = y[i]+h*dydt(y[i],t[i])
    return y

def RK2(y,t):
    y = np.zeros(len(t))
    y[0] = 2/25
    for i in range(len(t)-1):
        k1 = h*dydt(y[i],t[i])
        k2 = h*dydt(y[i]+(h/2),t[i]+(k1/2))
        y[i+1] = y[i]+k2

    return y

def Imp_euler(y0,t):
    y0 = (2/25)
    y = np.zeros(len(t))
    y[0] = y0
    for i in range(len(t)-1):
        y[i+1] = (y[i]-h*5*(t[i+1]**(2)))/((1-h*5))

    return y

#PLOTTNG THE FUNCTION FOR THREE DIFFERENT VALUE OF n = 25,250,2500 RESPECTIVELY

n = np.array([25,250,2500])
for i in range(len(n)):
    t = np.linspace(0,2,n[i])
    h = t[1]-t[0]
    plt.figure(figsize=(10,5),dpi=120)
    plt.plot(t,f(t),'b-',label='Analytical')
    plt.plot(t,Imp_euler((2/25),t),'k--',label='Imp_euler')
    plt.plot(t,RK2((2/25),t),'r--',label='RK2')
    plt.plot(t,euler((2/25),t),'g--',label='Forward_euler')
    plt.xlabel('t')

    plt.legend()
    plt.grid()

"""# PROBLEM - 2

FOR a = 3








"""

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-10,10,200)
h1 = x[1]-x[0]
t = np.linspace(0,25,25000)
h2 = t[1]-t[0]
#print(h2)
sigma = 1.0
a = 3.0

u = np.zeros([len(t),len(x)])
for i in range(len(x)):
    u[0,i] = np.exp(-(x[i]**(2))/(2*sigma**(2)))/(sigma*np.sqrt(2*np.pi))

plt.plot(x,u[0,:])

#FTCS SCHEME

for i in range(len(t)-1):
    for j in range(len(x)-1):
      u[i+1,j] = u[i,j]-(a*h2/(2*h1))*(u[i,j+1]-u[i,j-1])


    u[i+1,0] = u[i,-2]
    u[i+1,-1] = u[i,1]

indx = np.array([20,200,500,1000,2000,20000,23000,24000])
for l in range(len(indx)):
  plt.plot(x,u[indx[l],:], label='t='+str(indx[l]))
  plt.legend()

#indx = 200
#plt.plot(x,u[indx,:])
#indx = 500
#plt.plot(x,u[indx,:])

#UPWIND SCHEME
for i in range(len(t)-1):
  for j in range(len(x)-1):
    u[i+1,j] = u[i,j]-(a*h2/h1)*(u[i,j]-u[i,j-1])
  u[i+1,0] = u[i,-2]
  u[i+1,-1] = u[i,1]

#indx = 200
#plt.plot(x,u[:,indx])
#plt.plot(x,u[:,0])
indx = np.array([20,200,500,1000,1500,2000])
for l in range(len(indx)):
  plt.plot(x,u[indx[l],:],label='t='+str(indx[l]))
  plt.legend()

#LAX_WENDROFF SCHEME
c= a*h2/h1
for i in range(len(t)-1):
  for j in range(len(x)-1):
    u[i+1,j] = u[i,j]-c*0.5*(u[i,j+1]-u[i,j-1])+(c**(2))*0.5*(u[i,j+1]-2*u[i,j]+u[i,j-1])

  u[i+1,0] = u[i,-2]
  u[i+1,-1] = u[i,1]

indx = np.array([20,200,500,1000,1500,2000,20000])
for l in range(len(indx)):
  plt.plot(x,u[indx[l],:],label='t='+str(indx[l]))
  plt.legend()

#LAX_METHOD
c= a*h2/h1
for i in range(len(t)-1):
  for j in range(len(x)-1):
    u[i+1,j] = 0.5*(u[i,j+1]+u[i,j-1])-c*0.5*(u[i,j+1]-u[i,j-1])


  u[i+1,0] = u[i,-2]
  u[i+1,-1] = u[i,1]

indx = np.array([20,200,500,1000,2000])
for l in range(len(indx)):
  plt.plot(x,u[indx[l],:],label='t='+str(indx[l]))
  plt.legend()

#MAC_CORMACK
c= a*h2/h1
for i in range(len(t)-1):
  for j in range(len(x)-1):
    u[i+1,j] = u[i,j]-0.5*c*(u[i,j+1]-u[i,j-1])+0.5*(c**(2))*(u[i,j+1]-2*u[i,j]+u[i,j-1])


  u[i+1,0] = u[i,-2]
  u[i+1,-1] = u[i,1]

indx = np.array([20,200,500,1000,1500,2000,20000])
for l in range(len(indx)):
  plt.plot(x,u[indx[l],:],label='t='+str(indx[l]))
  plt.legend()

"""FOR a = -3"""

x = np.linspace(-10,10,200)
h1 = x[1]-x[0]
t = np.linspace(0,25,25000)
h2 = t[1]-t[0]
#print(h2)
sigma = 1.0
a = -3.0

u = np.zeros([len(t),len(x)])
for i in range(len(x)):
    u[0,i] = np.exp(-(x[i]**(2))/(2*sigma**(2)))/(sigma*np.sqrt(2*np.pi))

#FTCS SCHEME
for i in range(len(t)-1):
    for j in range(len(x)-1):
      u[i+1,j] = u[i,j]-(a*h2/(2*h1))*(u[i,j+1]-u[i,j-1])


    u[i+1,0] = u[i,-2]
    u[i+1,-1] = u[i,1]

indx = np.array([20,200,500,700,2000,20000,23000])
for l in range(len(indx)):
  plt.plot(x,u[indx[l],:], label='t='+str(indx[l]))
  plt.legend()

#UPWIND METHOD
for i in range(len(t)-1):
  for j in range(len(x)-1):
    u[i+1,j] = u[i,j]-(a*h2/h1)*(u[i,j+1]-u[i,j])
  u[i+1,0] = u[i,-2]
  u[i+1,-1] = u[i,1]

#indx = 200
#plt.plot(x,u[:,indx])
#plt.plot(x,u[:,0])
indx = np.array([20,200,500,700])
for l in range(len(indx)):
  plt.plot(x,u[indx[l],:],label='t='+str(indx[l]))
  plt.legend()

#LAX_WENDROFF SCHEME
c= a*h2/h1
for i in range(len(t)-1):
  for j in range(len(x)-1):
    u[i+1,j] = u[i,j]-c*0.5*(u[i,j+1]-u[i,j-1])+c**(2)*0.5*(u[i,j+1]-2*u[i,j]+u[i,j-1])

  u[i+1,0] = u[i,-2]
  u[i+1,-1] = u[i,1]


indx = np.array([20,200,500,700])
for l in range(len(indx)):
  plt.plot(x,u[indx[l],:],label='t='+str(indx[l]))
  plt.legend()

#LAX METHOD
c= a*h2/h1
for i in range(len(t)-1):
  for j in range(len(x)-1):
    u[i+1,j] = 0.5*(u[i,j+1]+u[i,j-1])-c*0.5*(u[i,j+1]-u[i,j-1])


  u[i+1,0] = u[i,-2]
  u[i+1,-1] = u[i,1]

indx = np.array([20,200,500,700])
for l in range(len(indx)):
  plt.plot(x,u[indx[l],:],label='t='+str(indx[l]))
  plt.legend()

#MC_CORMACK METHOD
c= a*h2/h1
for i in range(len(t)-1):
  for j in range(len(x)-1):
    u[i+1,j] = u[i,j]-c*0.5*(u[i,j+1]-u[i,j-1])+(0.5*c**(2))*(u[i,j+1]-2*u[i,j]+u[i,j-1])


  u[i+1,0] = u[i,-2]
  u[i+1,-1] = u[i,1]

indx = np.array([20,200,500,700])
for l in range(len(indx)):
  plt.plot(x,u[indx[l],:],label='t='+str(indx[l]))
  plt.legend()

"""FOR a =  10

"""

x = np.linspace(-10,10,200)                           # for a = 10
h1 = x[1]-x[0]
t = np.linspace(0,25,1000)
h2 = t[1]-t[0]
#print(h2)
sigma = 1.0
a = 10.0

u = np.zeros([len(t),len(x)])
for i in range(len(x)):
    u[0,i] = np.exp(-(x[i]**(2))/(2*sigma**(2)))/(sigma*np.sqrt(2*np.pi))

#FTCS SCHEME
for i in range(len(t)-1):
    for j in range(len(x)-1):
      u[i+1,j] = u[i,j]-(a*h2/(2*h1))*(u[i,j+1]-u[i,j-1])


    u[i+1,0] = u[i,-2]
    u[i+1,-1] = u[i,1]
indx = np.array([20,200,500])
for l in range(len(indx)):
  plt.plot(x,u[indx[l],:],label='t='+str(indx[l]))
  plt.legend()

# UPWIND SCHEME

for i in range(len(t)-1):
  for j in range(len(x)-1):
    u[i+1,j] = u[i,j]-(a*h2/h1)*(u[i,j]-u[i,j-1])
  u[i+1,0] = u[i,-2]
  u[i+1,-1] = u[i,1]

#indx = 200
#plt.plot(x,u[:,indx])
#plt.plot(x,u[:,0])
indx = np.array([20,200,500])
for l in range(len(indx)):
  plt.plot(x,u[indx[l],:],label='t='+str(indx[l]))
  plt.legend()

#LAX_WENDROFF SCHEME
c= a*h2/h1
for i in range(len(t)-1):
  for j in range(len(x)-1):
    u[i+1,j] = u[i,j]-c*0.5*(u[i,j+1]-u[i,j-1])+c**(2)*0.5*(u[i,j+1]-2*u[i,j]+u[i,j-1])

  u[i+1,0] = u[i,-2]
  u[i+1,-1] = u[i,1]


indx = np.array([20,200,500,700])
for l in range(len(indx)):
  plt.plot(x,u[indx[l],:],label='t='+str(indx[l]))
  plt.legend()

#LAX METHOD
c= a*h2/h1
for i in range(len(t)-1):
  for j in range(len(x)-1):
    u[i+1,j] = 0.5*(u[i,j+1]+u[i,j-1])-c*0.5*(u[i,j+1]-u[i,j-1])


  u[i+1,0] = u[i,-2]
  u[i+1,-1] = u[i,1]

indx = np.array([20,200,500,700])
for l in range(len(indx)):
  plt.plot(x,u[indx[l],:],label='t='+str(indx[l]))
  plt.legend()

#MC_CORMACK METHOD
c= a*h2/h1
for i in range(len(t)-1):
  for j in range(len(x)-1):
    u[i+1,j] = u[i,j]-c*0.5*(u[i,j+1]-u[i,j-1])+(0.5*c**(2))*(u[i,j+1]-2*u[i,j]+u[i,j-1])


  u[i+1,0] = u[i,-2]
  u[i+1,-1] = u[i,1]

indx = np.array([20,200,500,700])
for l in range(len(indx)):
  plt.plot(x,u[indx[l],:],label='t='+str(indx[l]))
  plt.legend()

